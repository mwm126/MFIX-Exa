

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>Particles on GPUs &mdash; MFiX-Exa  documentation</title>
  

  
  
  
  

  
  <script type="text/javascript" src="_static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="./" src="_static/documentation_options.js"></script>
        <script type="text/javascript" src="_static/jquery.js"></script>
        <script type="text/javascript" src="_static/underscore.js"></script>
        <script type="text/javascript" src="_static/doctools.js"></script>
        <script type="text/javascript" src="_static/language_data.js"></script>
        <script async="async" type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    
    <script type="text/javascript" src="_static/js/theme.js"></script>

    

  
  <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="_static/theme_overrides.css" type="text/css" />
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="Embedded Boundaries" href="EB.html" />
    <link rel="prev" title="Particle/Wall Interactions" href="ParticleWalls.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="index.html" class="icon icon-home"> MFiX-Exa
          

          
          </a>

          
            
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        
        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">Contents:</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="Introduction.html">MFiX-Exa Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="GettingStarted.html">Getting Started</a></li>
<li class="toctree-l1"><a class="reference internal" href="Inputs.html">Run-time Inputs</a></li>
<li class="toctree-l1"><a class="reference internal" href="Fluids.html">Solving the Fluid Equations</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="Particles.html">Particles</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="ParticleBasics.html">Particle Basics</a></li>
<li class="toctree-l2"><a class="reference internal" href="ParticleFluid.html">Particle/Fluid Interactions</a></li>
<li class="toctree-l2"><a class="reference internal" href="ParticleWalls.html">Particle/Wall Interactions</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="#">Particles on GPUs</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="EB.html">Embedded Boundaries</a></li>
</ul>

            
          
        </div>
        
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">MFiX-Exa</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="index.html">Docs</a> &raquo;</li>
        
          <li><a href="Particles.html">Particles</a> &raquo;</li>
        
      <li>Particles on GPUs</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="_sources/ParticlesOnGpus.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="particles-on-gpus">
<h1>Particles on GPUs<a class="headerlink" href="#particles-on-gpus" title="Permalink to this headline">¶</a></h1>
<p>The particle components of MFIX-Exa are a natural candidate for offloading to the GPU.
The particle kernels are compute-intensive and can in principle be processed asynchronously with parts of the fluid advance.
The core components of the particle method in MFIX-Exa are:</p>
<ul class="simple">
<li>Neighbor List Construction</li>
<li>Particle-Particle Collisions</li>
<li>Particle-Wall Collisions</li>
</ul>
<p>Of these operations, the neighbor list construction requires the most care.
A neighbor list is a pre-computed list of all the neighbors a given particle can interact with over the next <em>n</em> timesteps.
Neighbor lists are usually constructed by binning the particles by an interaction distance,
and then performing the N<sup>2</sup> distance check only on the particles in neighboring bins. In detail, the CPU version of the neighbor list algorithm is as follows:</p>
<ul class="simple">
<li>For each tile on each level, loop over the particles, identifying the bin it belongs to.</li>
<li>Add the particle to a linked-list for the cell that <cite>owns</cite> it.</li>
<li>For each cell, loop over all the particles, and then loop over all potential collisions partners in the neighboring cells.</li>
<li>If a collision partner is close enough, add it to that particle’s neighbor list.</li>
</ul>
<p>To port this algorithm to the GPU, we use the parallel algorithms library Thrust, distributed as part of the CUDA Toolkit. Thrust provides parallel sorting, searching, and prefix summing algorithms that are particularly useful in porting particle algorithms. To construct the neighbor list on the GPU, we follow the basic approach used by Canaba, a product of the Particle Co-Design Center:</p>
<ul class="simple">
<li>Sort the particles on each grid by bin, using a parallel counting sort. We use Thrust’s <cite>exclusive_scan</cite> function to implement the prefix sum phase of the sort, and hand-coded kernels for the rest. This step does not actually involving rearranging the particle data - rather, we compute a permutation that would put the particles in order without actually reordering them.</li>
<li>Once the particles are sorted by bin, we can loop over the particles in neighboring bins. We make two passes over the particles. First, we launch a kernel to count the number of collision partners for each particle.</li>
<li>Then, we sum these numbers and allocate space for our neighbor list.</li>
<li>Finally, we make a another pass over the particles, putting them into to list at the appropriate place.</li>
</ul>
<p>Note that we build a emph{full} neighbor list, meaning that if particle $i$ appears in particle $j$’s list, then particle $j$ also appears in particle $i$’s list. This simplifies the force-computation step when using these lists, since the forces and torques for a given particle can be updated without atomics.</p>
<p>The final on-grid neighbor list data structure consists of two arrays. First, we have the neighbor list itself, stored as a big, 1D array of particle indices. Then, we have an <cite>offsets</cite> array that stores, for each particle, where in the neighbor list array to look. The details of this data structure have been hidden inside an iterator, so that user code can look like:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="c1">// now we loop over the neighbor list and compute the forces</span>
 <span class="n">AMREX_FOR_1D</span> <span class="p">(</span> <span class="n">np</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span>
 <span class="p">{</span>
     <span class="n">ParticleType</span><span class="o">&amp;</span> <span class="n">p1</span> <span class="o">=</span> <span class="n">pstruct</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
     <span class="n">p1</span><span class="p">.</span><span class="n">rdata</span><span class="p">(</span><span class="n">PIdx</span><span class="o">::</span><span class="n">ax</span><span class="p">)</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">;</span>
     <span class="n">p1</span><span class="p">.</span><span class="n">rdata</span><span class="p">(</span><span class="n">PIdx</span><span class="o">::</span><span class="n">ay</span><span class="p">)</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">;</span>
     <span class="n">p1</span><span class="p">.</span><span class="n">rdata</span><span class="p">(</span><span class="n">PIdx</span><span class="o">::</span><span class="n">az</span><span class="p">)</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">;</span>

     <span class="k">for</span> <span class="p">(</span><span class="k">const</span> <span class="k">auto</span><span class="o">&amp;</span> <span class="nl">p2</span> <span class="p">:</span> <span class="n">nbor_data</span><span class="p">.</span><span class="n">getNeighbors</span><span class="p">(</span><span class="n">i</span><span class="p">))</span>
     <span class="p">{</span>
         <span class="n">Real</span> <span class="n">dx</span> <span class="o">=</span> <span class="n">p1</span><span class="p">.</span><span class="n">pos</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="o">-</span> <span class="n">p2</span><span class="p">.</span><span class="n">pos</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
         <span class="n">Real</span> <span class="n">dy</span> <span class="o">=</span> <span class="n">p1</span><span class="p">.</span><span class="n">pos</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">-</span> <span class="n">p2</span><span class="p">.</span><span class="n">pos</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
         <span class="n">Real</span> <span class="n">dz</span> <span class="o">=</span> <span class="n">p1</span><span class="p">.</span><span class="n">pos</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span> <span class="o">-</span> <span class="n">p2</span><span class="p">.</span><span class="n">pos</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span>

         <span class="p">...</span>
     <span class="p">}</span>
</pre></div>
</div>
<p>Note that, because of our use of managed memory to store the particle data and the neighbor list, the above code will work when compiled for either CPU or GPU.</p>
<p>The above algorithm deals with constructing a neighbor list for the particles on a single grid. When domain decomposition is used, one must also make copies of particles on adjacent grids, potentially performing the necessary MPI communication for grids associated with other processes. The routines <cite>fillNeighbors</cite>, which computes which particles needed to be ghosted to which grid, and <cite>updateNeighbors</cite>, which copies up-to-date data for particles that have already been ghosted, have also been offloaded to the GPU, using techniques similar to AMReX’s <cite>Redistribute</cite> routine. The important thing for users is that calling these functions does not trigger copying data off the GPU.</p>
<p>Once the neighbor list has been constructed, collisions with both particles and walls can easily be processed.</p>
<p>We have created a GPU branch of MFIX that is capable of running with GPU support. As of this writing, the following operations in MFIX have been offloaded:</p>
<ul class="simple">
<li>Neighbor particles / neighbor list construction</li>
<li>Particle-particle collisions</li>
<li>Particle-wall collisions</li>
<li>PIC Deposition (used in putting the drag force and solids volume fraction on the grid)</li>
</ul>
</div>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="EB.html" class="btn btn-neutral float-right" title="Embedded Boundaries" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="ParticleWalls.html" class="btn btn-neutral float-left" title="Particle/Wall Interactions" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2017-2018, MFiX-Exa Team

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>